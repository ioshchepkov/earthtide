---
title: "Introduction to the *earthtide* package"
author: "Jonathan Kennel, Beth Parker"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Code background 

The R earthtide package is a port of the Fortran ETERNA 3.4 (Wenzel, 1996) predict and analyze codes with the Kudryavtsev 2004 update.  The original Fortran code was rewritten in R, and C++ using Rcpp, RcppArmadillo, and RcppParallel. The package is useful for generating synthetic earth tides using highly accurate tidal catalogs for prediction and regression applications in R. Attempts were made to ensure that results were consistent with the ETERNA 3.4 results, however, there is always the possibility that a bug was introduced in during the conversion and update.  For the most feature rich version and up-to-date version of ETERNA please see http://ggp.bkg.bund.de/eterna/ that is updated by Klaus Schueller.


Wenzel, H.G. 1996: The nanogal software: Earth tide data processing package ETERNA 3.30. Bull. Inf. Marges Terrestres. 124, 9425-9439.

Kudryavtsev, S.M., 2004. Improved harmonic development of the Earth tide-generating potential. J. Geod. 77, 829â€“838.


## Setup

The first step to generate earthtides is to create the object with the prediction times, station, catalog and frequency details. The following are the most important parameters in most applications:

- **utc** is a vector of POSIXct times for earth tide prediction.  This should typically be a regular time series (equally spaced) as the method is most efficient for this case, however, irregular time series are also accepted.
- **latitude** numeric of length one.  The latitude of the monitoring location.
- **longitude** numeric of length one.  The longitude of the monitoring location.
- **cutoff** numeric of length one. Cutoff determines how many waves to include in the analysis.  A lower number yeilds more precise results but at the cost of runtime. A value of 1e-10 includes all waves in the catalog and may be quite slow. The default is 1e-6.
- **freq_range** is a data.frame of of the frequency ranges in cycles per day. It requires a column named start and an column named end which give the ranges for each wave group.


```{r newearthtide}
library(earthtide)

# generate times
tms <- as.POSIXct('2017-01-01 00:00:00', tz = 'UTC') + 0:(24*31) * 3600

# select constituent groups
# freq_range <- na.omit(eterna_wavegroups[eterna_wavegroups$time == '1 month', c('start', 'end')])

freq_range <- data.frame(start = 0, end = 8)

et <- Earthtide$new(utc = tms, 
                    latitude = 49.00937,
                    longitude = 8.40444,
                    elevation = 120,
                    cutoff = 1e-10,
                    catalog = 'hw95s',
                    freq_range = freq_range)
```

## LOD (length of day) tide and pole tide

The Length of Day (LOD) and Pole tides are calculated in this initial step.

```{r lodpole, echo = FALSE, fig.width = 6.5, fig.height = 5}
layout(matrix(1:2, ncol=1, nrow = 2))
par(mai = c(0.4, 0.9, 0.1, 0.1))
# Plot the results
et$lod_tide()
et$pole_tide()

plot(lod_tide~datetime, et$output,
     xlab = '',
     ylab = 'LOD tide (nm/s^2)',
     type='l',
     lwd = 2,
     col = '#5696BC')

plot(pole_tide~datetime, et$output,
     xlab = '',
     ylab = 'Pole tide (nm/s^2)',
     type='l',
     lwd = 2,
     col = '#5696BC')

```

## Predict

The predict method of the earthtide class returns the combined tide result as a vector. There are two options for this function:

- **method** is name of the prediction method. Currently valid options are "gravity", "tidal_potential", "tidal_tilt", "vertical_displacement", "vertical_strain", "areal_strain", "volume_strain", and "ocean_tides". 
- **astro_update** determines how often to phases are updated. For long time series (greater than 100,000 times) a value greater than 1 can speed up the results. In general, values greater than 1 will only be necessary for predicting at the minute or second scale or if you are predicting for many years.  There may be a slight loss of precision associated with this so if cutoff is small, this number should be also be small.  We suggest testing to achieve the desired precision.
  

```{r predict}

pred <- et$predict(method = 'gravity', astro_update = 24)

```


```{r predictplot, fig.width = 6.5, fig.height = 3, fig.ext='png', echo = FALSE}
# Plot the results
par(mai = c(0.6, 0.9, 0.1, 0.1))
plot(gravity~datetime, pred,
     ylab = 'Gravity nm/s^2',
     xlab = '',
     type='l',
     lwd = 2,
     col = '#5696BC',
     xaxs = 'i')
```


## Analyze

To generate curves for use in regression equations we use the analyze method instead of the predict method  All other arguments can remain the same.  This will generate normalized sin and cos terms for each wavegroup.  In the example we plot the first 5 of the 22 wave groups. These may be used in your preferred analyses.

```{r wg, fig.width = 6.5, fig.height = 8, fig.ext='png', echo = TRUE}
freq_range <- na.omit(eterna_wavegroups[eterna_wavegroups$time == '1 month', c('start', 'end')])

et <- Earthtide$new(utc = tms, 
                    latitude = 49.00937,
                    longitude = 8.40444,
                    elevation = 120,
                    cutoff = 1e-10,
                    catalog = 'hw95s',
                    freq_range = freq_range)

print(freq_range[1:5,], row.names = FALSE)
```

```{r analyze}

an <- et$analyze(method = 'gravity', astro_update = 1)

```

```{r analyzeplot, fig.width = 6.5, fig.height = 8, fig.ext='png', echo = FALSE}


layout(matrix(1:5, ncol=1, nrow = 5))
par(mai = c(0.3, 0.9, 0.1, 0.1))
for (i in seq(2, 11, 2)) {

  plot(an[,1], an[,i],
       ylab = 'nm/s^2',
       xlab = '',
       type = 'l',
       lwd = 2,
       col = '#AAB6A2')
  points(an[,1], an[,i+1],
         type = 'l',
         lwd = 2,
         col  = '#5696BC')

}


```
